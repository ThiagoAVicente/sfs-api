# name: E2E Tests

on:
  push:
    branches: [ main, dev ]
  pull_request:
    branches: [ main, dev ]
    types: [opened, synchronize]

jobs:
  e2e:
    runs-on: ubuntu-latest

    env:
      API_KEY: test-api-key-e2e
      REDIS_PASSWORD: testredis
      MINIO_ROOT_USER: minioadmin
      MINIO_ROOT_PASSWORD: minioadmin
      MINIO_KMS_SECRET_KEY: minio-kms:1B09jU7vbNS4qTPpnfaddRPtfStSS2tjnPWvMvDq/xc=
      SFS_FILE_BUCKET: default
      COLLECTION_NAME: default
      MODEL: sentence-transformers/all-MiniLM-L6-v2
      DEVICE: cpu
      CHUNK_SIZE: 256
      OVERLAP: 32
      NUM_WORKERS: 1
      DOMAIN: localhost
      DISABLE_DOCS: "false"
      MAX_FILE_SIZE_MB: "50"
      RATE_LIMIT_SEARCH: "1000"
      RATE_LIMIT_UPLOAD: "1000"
      RATE_LIMIT_DELETE: "1000"
      RATE_LIMIT_STATUS: "1000"
      RATE_LIMIT_DOWNLOAD: "1000"
      QUERY_PAGE_SIZE: "20"
      FILES_PAGE_SIZE: "20"

    steps:
      - uses: actions/checkout@v4

      - name: Start stack
        run: docker compose up -d --build --wait
        timeout-minutes: 10

      - name: Wait for API to be ready
        run: |
          for i in $(seq 1 30); do
            if curl -sk https://localhost/health | grep -q "healthy"; then
              echo "API is ready"
              exit 0
            fi
            echo "Waiting... ($i/30)"
            sleep 5
          done
          echo "API did not become ready in time"
          docker compose logs
          exit 1

      - name: Run E2E tests
        run: |
          BASE="https://localhost"
          KEY="test-api-key-e2e"
          COL="e2e-test-col"
          FAIL=0

          check() {
            local label=$1
            local expected=$2
            local actual=$3
            if [ "$actual" = "$expected" ]; then
              echo "  PASS $label"
            else
              echo "  FAIL $label — expected $expected, got $actual"
              FAIL=1
            fi
          }

          wait_for_job() {
            local version=$1
            local job_id=$2
            local label=$3
            local job_status=""
            for i in $(seq 1 20); do
              job_status=$(curl -sk -H "X-API-Key: $KEY" "$BASE/$version/index/status/$job_id" \
                | python3 -c "import sys,json; print(json.load(sys.stdin).get('status',''))" 2>/dev/null)
              if [ "$job_status" = "complete" ]; then
                echo "  Job complete after $((i*2))s"
                break
              fi
              sleep 2
            done
            check "$label" "complete" "$job_status"
          }

          echo "hello world semantic search test" > /tmp/e2e.txt

          # ======================================================
          echo ""
          echo "╔══════════════════════════════════════╗"
          echo "║        No-auth endpoints             ║"
          echo "╚══════════════════════════════════════╝"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" "$BASE/health")
          check "GET /health → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" "$BASE/")
          check "GET / → 200" "200" "$STATUS"

          # ======================================================
          echo ""
          echo "╔══════════════════════════════════════╗"
          echo "║        Auth enforcement              ║"
          echo "╚══════════════════════════════════════╝"

          for route in "v1/search" "v2/search"; do
            STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -X POST \
              -H "X-API-Key: wrong-key" \
              -H "Content-Type: application/json" \
              -d '{"query":"test"}' \
              "$BASE/$route")
            check "$route (wrong key) → 401" "401" "$STATUS"
          done

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -X POST \
            -H "X-API-Key: wrong-key" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            "$BASE/v1/index")
          check "v1/index (wrong key) → 401" "401" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" \
            -H "X-API-Key: wrong-key" \
            "$BASE/v2/collections")
          check "v2/collections (wrong key) → 401" "401" "$STATUS"

          # ======================================================
          echo ""
          echo "╔══════════════════════════════════════╗"
          echo "║          V1 endpoints                ║"
          echo "╚══════════════════════════════════════╝"

          echo ""
          echo "--- v1 index ---"

          RESP=$(curl -sk -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "update=false" \
            "$BASE/v1/index")
          STATUS=$(echo "$RESP" | python3 -c "import sys,json; d=json.load(sys.stdin); print('200' if 'job_id' in d else '400')" 2>/dev/null || echo "500")
          check "POST /v1/index → 200" "200" "$STATUS"
          V1_JOB_ID=$(echo "$RESP" | python3 -c "import sys,json; print(json.load(sys.stdin).get('job_id',''))" 2>/dev/null)

          # duplicate upload without update flag should 400
          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "update=false" \
            "$BASE/v1/index")
          check "POST /v1/index (duplicate, no update) → 400" "400" "$STATUS"

          # update=true should succeed
          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "update=true" \
            "$BASE/v1/index")
          check "POST /v1/index (update=true) → 200" "200" "$STATUS"

          echo ""
          echo "--- v1 job status ---"
          wait_for_job "v1" "$V1_JOB_ID" "GET /v1/index/status → complete"

          JOB_STATUS=$(curl -sk -H "X-API-Key: $KEY" "$BASE/v1/index/status/nonexistent-job" \
            | python3 -c "import sys,json; print(json.load(sys.stdin).get('status',''))" 2>/dev/null)
          check "GET /v1/index/status (bad id) → not_found" "not_found" "$JOB_STATUS"

          echo ""
          echo "--- v1 search ---"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d '{"query":"hello world","score_threshold":0.3}' \
            "$BASE/v1/search")
          check "POST /v1/search → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d '{"query":"","score_threshold":0.3}' \
            "$BASE/v1/search")
          check "POST /v1/search (empty query) → 400" "400" "$STATUS"

          RESULTS=$(curl -sk -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d '{"query":"hello world","score_threshold":0.3}' \
            "$BASE/v1/search")
          if echo "$RESULTS" | grep -q "hello world"; then
            echo "  PASS POST /v1/search returns matching result"
          else
            echo "  FAIL POST /v1/search did not return expected result — got: $RESULTS"
            FAIL=1
          fi

          echo ""
          echo "--- v1 files ---"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            "$BASE/v1/files/e2e.txt")
          check "GET /v1/files/e2e.txt → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            "$BASE/v1/files/nonexistent.txt")
          check "GET /v1/files/nonexistent.txt → 404" "404" "$STATUS"

          echo ""
          echo "--- v1 delete ---"

          RESP=$(curl -sk -H "X-API-Key: $KEY" -X DELETE "$BASE/v1/index/e2e.txt")
          STATUS=$(echo "$RESP" | python3 -c "import sys,json; d=json.load(sys.stdin); print('200' if 'job_id' in d else '500')" 2>/dev/null || echo "500")
          check "DELETE /v1/index/e2e.txt → 200" "200" "$STATUS"
          V1_DEL_JOB=$(echo "$RESP" | python3 -c "import sys,json; print(json.load(sys.stdin).get('job_id',''))" 2>/dev/null)
          wait_for_job "v1" "$V1_DEL_JOB" "DELETE /v1/index/e2e.txt job → complete"

          # ======================================================
          echo ""
          echo "╔══════════════════════════════════════╗"
          echo "║          V2 endpoints                ║"
          echo "╚══════════════════════════════════════╝"

          echo ""
          echo "--- v2 collections ---"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" "$BASE/v2/collections")
          check "GET /v2/collections → 200" "200" "$STATUS"

          echo ""
          echo "--- v2 index ---"

          RESP=$(curl -sk -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "collection=$COL" \
            -F "update=false" \
            "$BASE/v2/index")
          STATUS=$(echo "$RESP" | python3 -c "import sys,json; d=json.load(sys.stdin); print('200' if 'job_id' in d else '400')" 2>/dev/null || echo "500")
          check "POST /v2/index → 200" "200" "$STATUS"
          V2_JOB_ID=$(echo "$RESP" | python3 -c "import sys,json; print(json.load(sys.stdin).get('job_id',''))" 2>/dev/null)

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "collection=$COL" \
            -F "update=false" \
            "$BASE/v2/index")
          check "POST /v2/index (duplicate, no update) → 400" "400" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -F "file=@/tmp/e2e.txt;type=text/plain" \
            -F "collection=$COL" \
            -F "update=true" \
            "$BASE/v2/index")
          check "POST /v2/index (update=true) → 200" "200" "$STATUS"

          echo ""
          echo "--- v2 job status ---"
          wait_for_job "v2" "$V2_JOB_ID" "GET /v2/index/status → complete"

          JOB_STATUS=$(curl -sk -H "X-API-Key: $KEY" "$BASE/v2/index/status/nonexistent-job" \
            | python3 -c "import sys,json; print(json.load(sys.stdin).get('status',''))" 2>/dev/null)
          check "GET /v2/index/status (bad id) → not_found" "not_found" "$JOB_STATUS"

          echo ""
          echo "--- v2 collections (custom should appear) ---"

          COLS=$(curl -sk -H "X-API-Key: $KEY" "$BASE/v2/collections")
          if echo "$COLS" | grep -q "$COL"; then
            echo "  PASS GET /v2/collections contains $COL"
          else
            echo "  FAIL GET /v2/collections does not contain $COL — got: $COLS"
            FAIL=1
          fi

          echo ""
          echo "--- v2 search ---"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d '{"query":"hello world","score_threshold":0.3}' \
            "$BASE/v2/search")
          check "POST /v2/search (default col) → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d "{\"query\":\"hello world\",\"score_threshold\":0.3,\"collections\":[\"$COL\"]}" \
            "$BASE/v2/search")
          check "POST /v2/search (custom col) → 200" "200" "$STATUS"

          RESULTS=$(curl -sk -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d "{\"query\":\"hello world\",\"score_threshold\":0.3,\"collections\":[\"$COL\"]}" \
            "$BASE/v2/search")
          if echo "$RESULTS" | grep -q "hello world"; then
            echo "  PASS POST /v2/search returns matching result"
          else
            echo "  FAIL POST /v2/search did not return expected result — got: $RESULTS"
            FAIL=1
          fi

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d "{\"query\":\"hello world\",\"score_threshold\":0.3,\"collections\":[\"$COL\",\"default\"]}" \
            "$BASE/v2/search")
          check "POST /v2/search (multi-col) → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" \
            -H "Content-Type: application/json" \
            -d '{"query":"","score_threshold":0.3}' \
            "$BASE/v2/search")
          check "POST /v2/search (empty query) → 400" "400" "$STATUS"

          echo ""
          echo "--- v2 files ---"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" "$BASE/v2/files/")
          check "GET /v2/files/ → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" "$BASE/v2/files/?collection=$COL")
          check "GET /v2/files/?collection=$COL → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" "$BASE/v2/files/$COL/e2e.txt")
          check "GET /v2/files/$COL/e2e.txt → 200" "200" "$STATUS"

          STATUS=$(curl -sk -o /dev/null -w "%{http_code}" -H "X-API-Key: $KEY" "$BASE/v2/files/$COL/nonexistent.txt")
          check "GET /v2/files/$COL/nonexistent.txt → 404" "404" "$STATUS"

          echo ""
          echo "--- v2 delete ---"

          RESP=$(curl -sk -H "X-API-Key: $KEY" -X DELETE "$BASE/v2/index/$COL/e2e.txt")
          STATUS=$(echo "$RESP" | python3 -c "import sys,json; d=json.load(sys.stdin); print('200' if 'job_id' in d else '500')" 2>/dev/null || echo "500")
          check "DELETE /v2/index/$COL/e2e.txt → 200" "200" "$STATUS"
          V2_DEL_JOB=$(echo "$RESP" | python3 -c "import sys,json; print(json.load(sys.stdin).get('job_id',''))" 2>/dev/null)
          wait_for_job "v2" "$V2_DEL_JOB" "DELETE /v2/index/$COL/e2e.txt job → complete"

          # ======================================================
          echo ""
          echo "╔══════════════════════════════════════╗"
          echo "║            Summary                   ║"
          echo "╚══════════════════════════════════════╝"
          if [ "$FAIL" = "0" ]; then
            echo "All E2E tests passed!"
          else
            echo "Some E2E tests FAILED"
            exit 1
          fi

      - name: Print logs on failure
        if: failure()
        run: docker compose logs
